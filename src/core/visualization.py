import matplotlib.pyplot as plt
import numpy as np
import warnings
import datetime as dt
from .utilities import *

from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import matplotlib.colors as colors
import matplotlib as mpl
import copy
import uuid
from pathlib import Path
from scipy import interp
from itertools import cycle

import dask.array as da
import xarray as xr
from sklearn.metrics import roc_curve, auc
from sklearn.calibration import calibration_curve
from scipy import stats
from scipy.ndimage import gaussian_filter

def __gaussian_smooth(X, x_lat_dim='Y', x_lon_dim='X', x_sample_dim='T', x_feature_dim='M', kernel=(9,9), use_dask=False, feature_chunks=1, sample_chunks=1, destination='.xcast_worker_space' ):
    check_all(X, x_lat_dim, x_lon_dim,  x_sample_dim, x_feature_dim)
    #X1 = fill_space_mean(X, x_lat_dim, x_lon_dim,  x_sample_dim, x_feature_dim )
    X1 = X.chunk({x_feature_dim: max(X.shape[list(X.dims).index(x_feature_dim)] // feature_chunks, 1), x_sample_dim: max(X.shape[list(X.dims).index(x_sample_dim)] // sample_chunks, 1) }).transpose(x_feature_dim, x_sample_dim, x_lat_dim, x_lon_dim)

    hdf=None
    results, seldct = [], {}
    feature_ndx = 0
    for i in range(len(X1.chunks[list(X1.dims).index(x_feature_dim)])):
        sample_ndx = 0
        results.append([])
        for j in range(len(X1.chunks[list(X1.dims).index(x_sample_dim)])):
            x_isel = {x_feature_dim: slice(feature_ndx, feature_ndx + X1.chunks[list(X1.dims).index(x_feature_dim)][i]), x_sample_dim: slice(sample_ndx, sample_ndx + X1.chunks[list(X1.dims).index(x_sample_dim)][j])}
            results[i].append(__gaussian_smooth_chunk(X1.isel(**x_isel), feature_ndx, sample_ndx, x_lat_dim, x_lon_dim,  x_sample_dim, x_feature_dim , use_dask=use_dask, kernel=kernel, hdf=hdf))
            sample_ndx += X1.chunks[list(X1.dims).index(x_sample_dim)][j]
        feature_ndx += X1.chunks[list(X1.dims).index(x_feature_dim)][i]
        results[i] = np.concatenate(results[i], axis=1)
    results = np.concatenate(results, axis=0)
    attrs = X1.attrs({'generated by': 'XCast Gaussian Smoothing {}'.format(kernel)})
    return xr.DataArray(data=results, coords=X1.coords, dims=X1.dims, attrs=attrs)


def __gaussian_smooth_chunk(X, feature_ndx, sample_ndx, x_lat_dim='Y', x_lon_dim='X', x_sample_dim='T', x_feature_dim='M', kernel=(9,9), use_dask=False, hdf=None ):
    res = []
    data = X.values
    for i in range(data.shape[0]):
        res.append([])
        for j in range(data.shape[1]):
            toblur = data[i, j, :, :]
            mask = np.isnan(toblur)
            toblur2 = toblur.copy()
            toblur2[mask] = np.nanmean(toblur)
            blurred = gaussian_filter(toblur2, sigma=kernel)
            blurred[mask] = np.nan
            res[i].append(blurred)
    res = np.asarray(res)
    return res




class MidpointNormalize(colors.Normalize):
    """Helper class for setting the midpoint of a pyplot colorbar"""
    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
        midpoint = midpoint
        self.vmin, self.vmax, self.midpoint = vmin, vmax, midpoint
        colors.Normalize.__init__(self, vmin, vmax, clip)

    def __call__(self, value, clip=None):
        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
        return np.ma.masked_array(np.interp(value, x, y))


def view_roc(X, Y, x_lat_dim=None, x_lon_dim=None, x_feature_dim=None, x_sample_dim=None, y_lat_dim=None, y_lon_dim=None, y_feature_dim=None, y_sample_dim=None ):
    """where X is predicted, and Y is observed"""
    x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim = guess_coords(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim = guess_coords(Y, y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)

    check_all(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    check_all(Y, y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)

    #X1 = X.transpose(x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    #Y1 = Y.transpose(y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)
    #x_data = X1.values.reshape(len(X1.coords[x_lat_dim].values)*len(X1.coords[x_lon_dim].values)*len(X1.coords[x_sample_dim].values), len(X1.coords[x_feature_dim].values))
    #y_data = Y1.values.reshape(len(Y1.coords[y_lat_dim].values)*len(Y1.coords[y_lon_dim].values)*len(Y1.coords[y_sample_dim].values), len(Y1.coords[y_feature_dim].values))
    x_data = X.stack(point=(x_lat_dim, x_lon_dim, x_sample_dim)).transpose('point', x_feature_dim).values 
    y_data = Y.stack(point=(y_lat_dim, y_lon_dim, y_sample_dim)).transpose('point', y_feature_dim).values 

    
    tst = x_data *y_data
    x_data = x_data[~np.isnan(tst).any(axis=1)]
    y_data = y_data[~np.isnan(tst).any(axis=1)]
    n_classes = len(X.coords[x_feature_dim].values)
    fpr = dict()
    tpr = dict()
    roc_auc = dict()
    for i in range(n_classes):
        fpr[i], tpr[i], _ = roc_curve(y_data[:, i], x_data[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    # First aggregate all false positive rates
    all_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))

    # Then interpolate all ROC curves at this points
    mean_tpr = np.zeros_like(all_fpr)
    for i in range(n_classes):
        mean_tpr += interp(all_fpr, fpr[i], tpr[i])

    # Finally average it and compute AUC
    mean_tpr /= n_classes

    fpr["macro"] = all_fpr
    tpr["macro"] = mean_tpr
    roc_auc["macro"] = auc(fpr["macro"], tpr["macro"])

    # Plot all ROC curves
    plt.figure()
    plt.plot(fpr["macro"], tpr["macro"],
                label='macro-average ROC curve (area = {0:0.2f})'
                ''.format(roc_auc["macro"]),
                color='navy', linestyle=':', linewidth=4)

    colors = cycle(['aqua', 'darkorange', 'cornflowerblue'])
    for i, color in zip(range(n_classes), colors):
        plt.plot(fpr[i], tpr[i], color=color, lw=2,
                label='ROC curve of class {0} (area = {1:0.2f})'
                ''.format(X.coords[x_feature_dim].values[i], roc_auc[i]))

    plt.plot([0, 1], [0, 1], 'k--', lw=2)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('ROC Curve')
    plt.legend(loc="lower right")
    plt.show()


import numpy as np
import matplotlib.pyplot as plt 
from matplotlib.patches import Patch, Polygon 
from operator import sub

def reliability_diagram(ypred, t, title=None):
    countnonnan = np.ones_like(ypred.squeeze())[~np.isnan(ypred.squeeze())].sum()
    #assert len(ypred.shape) == 2 and ypred.shape[1] == 1, 'ypred must be of shape n_samples x 1'
    assert ypred.shape == t.shape, 'inconsistent shapes between ypred and t - {} vs {}'.format(ypred.shape, t.shape)
    epoelm_rel = []
    epoelm_hist = []
    for i in range(10):
        n = np.ones_like(ypred.squeeze())[np.where((ypred.squeeze() >= (i /10.0)) & (ypred.squeeze() < (i/10.0 +0.1)) ) ].sum()
        m = np.ones_like(ypred.squeeze())[np.where((ypred.squeeze() >= (i /10.0)) & (ypred.squeeze() < (i/10.0 +0.1)) & (t.squeeze() == 1) )].sum()
        epoelm_hist.append(n)
        if n == 0:
            reliability = np.nan 
        else:
            reliability = m / n#n * ( m / n + (i/10+0.5) ) ** 2
        epoelm_rel.append(reliability) # / epoelm_xval.shape[0])
    epoelm_hist = np.asarray(epoelm_hist) / countnonnan

    #plt.hist(epoelm_xval[:, 0], bins=11)
    ur = Polygon([[0.33, 0.33 ], [0.33, 1], [1,1], [1, 1.33/2.0]], facecolor='gray', alpha=0.25)
    bl = Polygon([[0.33, 0.33 ], [0.33, 0], [0,0], [0, 0.33/2.0]], facecolor='gray', alpha=0.25)
    ax = plt.gca()
    ax.add_patch(ur)
    ax.add_patch(bl)

    plt.text(0.66, 0.28, 'No Resolution')
    figW, figH = ax.get_figure().get_size_inches()
    _, _, w, h = ax.get_position().bounds
    disp_ratio = (figH * h) / (figW * w)
    data_ratio = sub(*ax.get_ylim()) / sub(*ax.get_xlim())
    angle = (180.0/np.pi)*np.arctan(disp_ratio / data_ratio)
    plt.text(0.66, 0.45, 'No Skill', rotation=angle*0.5)
    plt.plot([0, 1], [0,1], lw=0.25, linestyle='dotted')
    noskill = plt.plot([0, 1], [0.33/2.0,1.33/2.0], lw=0.5, linestyle='dotted')
    plt.plot([0.33, 0.33], [0,1], lw=0.5, linestyle='dotted')
    noresolution = plt.plot([0, 1], [0.33,0.33], lw=0.5, linestyle='dotted')
    plt.gca().set_xlabel('Forecast Probability')
    plt.gca().set_ylabel('Observed Relative Frequency')
    plt.plot([i / 10 +0.05 for i in range(10) ], epoelm_rel, marker='.', lw=1, color='red')
    plt.bar([i / 10 + 0.05 for i in range(10)], epoelm_hist, fill=False, width=0.08, alpha=0.66)
    if title is not None: 
        plt.set_title(title)
    return plt.gca()


def view_taylor(X, Y, x_lat_dim=None, x_lon_dim=None, x_feature_dim=None, x_sample_dim=None, y_lat_dim=None, y_lon_dim=None, y_feature_dim=None, y_sample_dim=None, loc="lower left" ):
    """where X is predicted, and Y is observed"""
    x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim = guess_coords(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim = guess_coords(Y, y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)

    check_all(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    check_all(Y, y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)

    X1 = X.transpose(x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    Y1 = Y.transpose(y_lat_dim, y_lon_dim, y_sample_dim, y_feature_dim)
    #x_data = X1.values.reshape(len(X1.coords[x_lat_dim].values)*len(X1.coords[x_lon_dim].values)*len(X1.coords[x_sample_dim].values), len(X1.coords[x_feature_dim].values))
    #y_data = Y1.values.reshape(len(Y1.coords[y_lat_dim].values)*len(Y1.coords[y_lon_dim].values)*len(Y1.coords[y_sample_dim].values), len(Y1.coords[y_feature_dim].values))
    x_data = X.stack(point=(x_lat_dim, x_lon_dim, x_sample_dim)).transpose('point', x_feature_dim).values 
    y_data = Y.stack(point=(y_lat_dim, y_lon_dim, y_sample_dim)).transpose('point', y_feature_dim).values 

    
    tst = x_data *y_data
    x_data = x_data[~np.isnan(tst).any(axis=1)]
    y_data = y_data[~np.isnan(tst).any(axis=1)]
    n_classes = len(X.coords[x_feature_dim].values)

    obs_stddev = y_data.std()
    stddevs = x_data.std(axis=0)

    correlations = []
    for i in range(n_classes):
        try:
            coef, p = stats.pearsonr(np.squeeze(x_data[:,i]).astype(float), np.squeeze(y_data[:,0]).astype(float))
            correlations.append(coef)
        except:
            correlations.append(np.nan)
    obs_cor = 1.0
    correlations = np.asarray(correlations)

    obs_rmsd = 0
    rmsds = np.sqrt(obs_stddev**2 + stddevs**2 - 2* obs_stddev*stddevs*correlations)

    angles = (1 - correlations ) * np.pi / 2.0

    xs = [np.cos(angles[i]) * stddevs[i] for i in range(stddevs.shape[0])]
    ys = [np.sin(angles[i]) * stddevs[i] for i in range(stddevs.shape[0])]

    fig = plt.figure(frameon=False, figsize=(5,5))
    colors = cycle(['aqua', 'darkorange', 'cornflowerblue', 'purple', 'green'])
    for i, color in zip(range(len(xs)), colors):
        plt.scatter(xs[i], ys[i], color=color, lw=2, label='Model {}'.format(X.coords[x_feature_dim].values[i]))
    plt.scatter(obs_stddev, 0, color='red', label='Observations')

    for i in range(4):
        circle1 = plt.Circle((obs_stddev, 0), max(rmsds)*((i+1) / 4.0), edgecolor='green', fill=False, alpha=0.5, linestyle='-.')
        fig.axes[0].add_patch(circle1)
        fig.axes[0].annotate('{:>02.2}'.format(max(rmsds)*((i+1) / 4.0)), (obs_stddev, max(rmsds)*((i+1.1) / 4.0)), (obs_stddev, max(rmsds)*((i+1.1) / 4.0)), color='green', alpha=0.5, size=8)

    fig.axes[0].annotate('RMS', (obs_stddev, max(rmsds)*1.1), (obs_stddev, max(rmsds)*1.1), color='green', alpha=0.5)


    for i in range(7):
        circle1 = plt.Circle((0, 0), obs_stddev*(i / 3.0), edgecolor='black', fill=False)
        fig.axes[0].add_patch(circle1)


    for i in range(5):
        angle = np.pi / 2.0 * (1 - (i+0.5)/5.0)
        plt.plot([0, np.cos(angle)*obs_stddev*1.5], [0, np.sin(angle)*obs_stddev*1.5], linewidth=0.5, color='blue', alpha=0.5, linestyle='-.')
        fig.axes[0].annotate('{}'.format((i+0.5) / 5.0), (np.cos(angle)*obs_stddev*1.5, np.sin(angle)*obs_stddev*1.5), (np.cos(angle)*obs_stddev*1.5, np.sin(angle)*obs_stddev*1.5), alpha=0.5, color='blue', size=8, rotation=(1 - (i+0.5)/5.0)*90)
    fig.axes[0].annotate('Peason Correlation', (np.cos(np.pi/4)*obs_stddev*1.45, np.sin(np.pi/4)*obs_stddev*1.45), (np.cos(np.pi/4)*obs_stddev*1.45, np.sin(np.pi/4)*obs_stddev*1.45), color='blue', rotation=315, alpha=0.5)

    plt.xlim([0,  obs_stddev * 1.6])
    plt.ylim([0,  obs_stddev * 1.6])
    plt.xticks([obs_stddev * i / 3.0 for i in range(5)], ['{:<02.2}'.format(obs_stddev * i / 3.0) for i in range(5)])
    plt.yticks([obs_stddev * i / 3.0 for i in range(5)], ['{:<02.2}'.format(obs_stddev * i / 3.0) for i in range(5)])
    plt.xlabel('Standard Deviation')
    plt.ylabel('Standard Deviation')
    plt.title('Taylor Diagram')
    plt.legend(loc=loc)
    plt.show()

import cartopy.crs as ccrs
import matplotlib.pyplot as plt 
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import matplotlib.colors as colors


def view_probabilistic(X, x_lat_dim=None, x_lon_dim=None, x_sample_dim=None, x_feature_dim=None):
    x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim = guess_coords_view_prob(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    assert x_sample_dim is None, 'View probabilistic requires you to select across sample dim to eliminate that dimension first'
    #check_all(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)
    assert x_lat_dim in X.coords.keys(), 'XCast requires a dataset_lat_dim to be a coordinate on X'
    assert x_lon_dim in X.coords.keys(), 'XCast requires a dataset_lon_dim to be a coordinate on X'
    assert x_feature_dim in X.coords.keys(), 'XCast requires a dataset_feature_dim to be a coordinate on X'
    check_type(X, x_lat_dim, x_lon_dim, x_sample_dim, x_feature_dim)

    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(7, 9), subplot_kw={'projection': ccrs.PlateCarree()})
    bounds = [40,45,50,55,60,65,70,75,80]
    nbounds = [40,45,50]
    mask = X.mean(x_feature_dim)
    mask = mask.where(np.isnan(mask), other=1)
    argmax = X.fillna(-999).argmax('M') * mask

    flat = mask.where(argmax != 2, other=X.isel(M=2))
    flat = flat.where(argmax != 1, other=X.isel(M=1))
    flat = flat.where(argmax != 0, other=X.isel(M=0)) * mask 

    def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
        new_cmap = colors.LinearSegmentedColormap.from_list(
            'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),
            cmap(np.linspace(minval, maxval, n)))
        return new_cmap

    graycmap = truncate_colormap(plt.get_cmap('Greys'),0.0, 0.6 )
    graycmap = plt.get_cmap(graycmap, 4)

    CS3 = flat.where(argmax == 2, other=np.nan).plot(ax=ax, add_colorbar=False, vmin=0.35, vmax=0.85, cmap=plt.get_cmap('Blues', 9))
    CS1 = flat.where(argmax == 0, other=np.nan).plot(ax=ax, add_colorbar=False, vmin=0.35, vmax=0.85, cmap=plt.get_cmap('YlOrRd', 9))
    CS2 = flat.where(argmax == 1, other=np.nan).plot(ax=ax, add_colorbar=False, vmin=0.35, vmax=0.55, cmap=plt.get_cmap(graycmap, 4))

    ax.coastlines()
    axins_f_bottom = inset_axes(ax, width="35%", height="5%", loc='lower left', bbox_to_anchor=(-0, -0.15, 1, 1), bbox_transform=ax.transAxes,borderpad=0.1 )
    axins2_bottom = inset_axes(ax, width="20%",  height="5%", loc='lower center', bbox_to_anchor=(-0.0, -0.15, 1, 1), bbox_transform=ax.transAxes, borderpad=0.1 )
    axins3_bottom = inset_axes(ax, width="35%",  height="5%", loc='lower right', bbox_to_anchor=(0, -0.15, 1, 1), bbox_transform=ax.transAxes, borderpad=0.1 )


    cbar_fbl = fig.colorbar(CS1, ax=ax, cax=axins_f_bottom, orientation='horizontal')
    cbar_fbl.set_label('BN (%)') 
    cbar_fbl.set_ticks([i /100.0 for i in bounds])
    cbar_fbl.set_ticklabels(bounds)


    cbar_fbc = fig.colorbar(CS2, ax=ax,  cax=axins2_bottom, orientation='horizontal')
    cbar_fbc.set_label('NN (%)') 
    cbar_fbc.set_ticks([i /100.0 for i in nbounds])
    cbar_fbc.set_ticklabels(nbounds)

    cbar_fbr = fig.colorbar(CS3, ax=ax,  cax=axins3_bottom, orientation='horizontal')
    cbar_fbr.set_label('AN (%)') 
    cbar_fbr.set_ticks([i /100.0 for i in bounds])
    cbar_fbr.set_ticklabels(bounds)
